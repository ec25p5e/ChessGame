


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Window</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">gui</a>
</div>

<h1>Coverage Summary for Class: Window (gui)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Window</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/66)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Window$AIThinkThank</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$BoardDirection</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$BoardDirection$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$BoardDirection$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$BoardPanel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$TableGameAIWatcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$Tile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$Tile$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/53)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/195)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package gui;
&nbsp;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import core.move.*;
&nbsp;import core.board.VirtualBoard;
&nbsp;import core.board.VirtualBoardUtils;
&nbsp;import core.pieces.piece.Piece;
&nbsp;import core.player.ai.PlayerType;
&nbsp;import core.player.ai.StockAlphaBeta;
&nbsp;import lombok.Getter;
&nbsp;import lombok.Setter;
&nbsp;import util.Constants;
&nbsp;
&nbsp;import javax.imageio.ImageIO;
&nbsp;import javax.swing.*;
&nbsp;import java.awt.*;
&nbsp;import java.awt.event.KeyEvent;
&nbsp;import java.awt.event.MouseEvent;
&nbsp;import java.awt.event.MouseListener;
&nbsp;import java.awt.image.BufferedImage;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.util.*;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static javax.swing.SwingUtilities.*;
&nbsp;
&nbsp;/**
&nbsp; * Questa classe rappresenta la GUI e i suoi elementi collegati.
&nbsp; */
&nbsp;@Getter
<b class="nc">&nbsp;@Setter</b>
&nbsp;public final class Window extends Observable {
<b class="nc">&nbsp;    private final JFrame windowFrame;</b>
<b class="nc">&nbsp;    private final MoveLog moveLog;</b>
<b class="nc">&nbsp;    private final TakenPiecesPanel takenPiecesPanel;</b>
&nbsp;
<b class="nc">&nbsp;    private VirtualBoard virtualBoard;</b>
<b class="nc">&nbsp;    private BoardDirection boardDirection;</b>
<b class="nc">&nbsp;    private Piece sourceTile;</b>
<b class="nc">&nbsp;    private Piece humanMovedPiece;</b>
<b class="nc">&nbsp;    private BoardPanel boardPanel;</b>
<b class="nc">&nbsp;    private Move computerMove;</b>
<b class="nc">&nbsp;    private boolean highlightLegalMoves;</b>
&nbsp;
<b class="nc">&nbsp;    private static final Window INSTANCE = new Window();</b>
&nbsp;
<b class="nc">&nbsp;    private Window() {</b>
<b class="nc">&nbsp;        this.windowFrame = new JFrame(Constants.WINDOW_TITLE);</b>
<b class="nc">&nbsp;        final JMenuBar tableMenuBar = new JMenuBar();</b>
<b class="nc">&nbsp;        this.populateMenuBar(tableMenuBar);</b>
<b class="nc">&nbsp;        this.windowFrame.setJMenuBar(tableMenuBar);</b>
<b class="nc">&nbsp;        this.windowFrame.setLayout(new BorderLayout());</b>
<b class="nc">&nbsp;        this.virtualBoard = VirtualBoard.getDefaultBoard();</b>
<b class="nc">&nbsp;        this.boardDirection = BoardDirection.NORMAL;</b>
<b class="nc">&nbsp;        this.highlightLegalMoves = false;</b>
<b class="nc">&nbsp;        this.boardPanel = new BoardPanel();</b>
<b class="nc">&nbsp;        this.moveLog = new MoveLog();</b>
<b class="nc">&nbsp;        this.takenPiecesPanel = new TakenPiecesPanel();</b>
<b class="nc">&nbsp;        this.addObserver(new TableGameAIWatcher());</b>
<b class="nc">&nbsp;        this.windowFrame.add(this.takenPiecesPanel, BorderLayout.WEST);</b>
<b class="nc">&nbsp;        this.windowFrame.add(this.boardPanel, BorderLayout.CENTER);</b>
<b class="nc">&nbsp;        this.windowFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</b>
<b class="nc">&nbsp;        this.windowFrame.setSize(Constants.WINDOW_DIMENSION);</b>
<b class="nc">&nbsp;        this.windowFrame.setVisible(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Window get() {
<b class="nc">&nbsp;        return INSTANCE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void start() {
<b class="nc">&nbsp;        Window.get().getMoveLog().clear();</b>
<b class="nc">&nbsp;        Window.get().getTakenPiecesPanel().redo(Window.get().getMoveLog());</b>
<b class="nc">&nbsp;        Window.get().getBoardPanel().drawBoard(Window.get().getVirtualBoard());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param playerType
&nbsp;     */
&nbsp;    private void moveMadeUpdate(final PlayerType playerType) {
<b class="nc">&nbsp;        setChanged();</b>
<b class="nc">&nbsp;        notifyObservers(playerType);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateGameBoard(final VirtualBoard board) {
<b class="nc">&nbsp;        this.virtualBoard = board;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateComputerMove(final Move move) {
<b class="nc">&nbsp;        this.computerMove = move;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void populateMenuBar(final JMenuBar tableMenuBar) {
<b class="nc">&nbsp;        tableMenuBar.add(this.createOptionsMenu());</b>
<b class="nc">&nbsp;        tableMenuBar.add(this.createPreferencesMenu());</b>
&nbsp;    }
&nbsp;
&nbsp;    private JMenu createOptionsMenu() {
<b class="nc">&nbsp;        final JMenu optionsMenu = new JMenu(&quot;Opzioni&quot;);</b>
<b class="nc">&nbsp;        optionsMenu.setMnemonic(KeyEvent.VK_O);</b>
&nbsp;
&nbsp;
&nbsp;        // Annullare ultima mossa
<b class="nc">&nbsp;        final JMenuItem undoLastMove = new JMenuItem(&quot;Annulla ultima mossa&quot;, KeyEvent.VK_Z);</b>
<b class="nc">&nbsp;        undoLastMove.addActionListener(e -&gt; {</b>
<b class="nc">&nbsp;            if(Window.get().getMoveLog().size() &gt; 0)</b>
<b class="nc">&nbsp;                this.undoLastMove();</b>
&nbsp;        });
<b class="nc">&nbsp;        optionsMenu.add(undoLastMove);</b>
&nbsp;
<b class="nc">&nbsp;        return optionsMenu;</b>
&nbsp;    }
&nbsp;
&nbsp;    private JMenu createPreferencesMenu() {
<b class="nc">&nbsp;        final JMenu preferencesMenu = new JMenu(&quot;Preferenze&quot;);</b>
<b class="nc">&nbsp;        preferencesMenu.setMnemonic(KeyEvent.VK_P);</b>
&nbsp;
&nbsp;
&nbsp;        // Invertire la board (flip board)
<b class="nc">&nbsp;        final JMenuItem flipBoardItem = new JMenuItem(&quot;Inverti scacchiera&quot;);</b>
<b class="nc">&nbsp;        flipBoardItem.addActionListener(e -&gt; {</b>
<b class="nc">&nbsp;            this.boardDirection = this.boardDirection.opposite();</b>
<b class="nc">&nbsp;            this.boardPanel.drawBoard(this.virtualBoard);</b>
&nbsp;        });
<b class="nc">&nbsp;        preferencesMenu.add(flipBoardItem);</b>
&nbsp;
&nbsp;        // Aggiungi una riga per dividere il menu
<b class="nc">&nbsp;        preferencesMenu.addSeparator();</b>
&nbsp;
&nbsp;        // Evidenzia le mosse possibili
<b class="nc">&nbsp;        final JCheckBoxMenuItem cbLegalMoveHighlighter = new JCheckBoxMenuItem(</b>
&nbsp;                &quot;Mostra aiuto mosse&quot;, false);
&nbsp;
<b class="nc">&nbsp;        cbLegalMoveHighlighter.addActionListener(e -&gt; highlightLegalMoves = cbLegalMoveHighlighter.isSelected());</b>
&nbsp;
<b class="nc">&nbsp;        preferencesMenu.add(cbLegalMoveHighlighter);</b>
&nbsp;
<b class="nc">&nbsp;        return preferencesMenu;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private void undoLastMove() {
<b class="nc">&nbsp;       final Move lastMove = Window.get().getMoveLog().removeMove(Window.get().getMoveLog().size() - 1);</b>
<b class="nc">&nbsp;       this.virtualBoard = this.virtualBoard.getCurrentPlayer().unMakeMove(lastMove).toBoard();</b>
<b class="nc">&nbsp;       this.computerMove = null;</b>
&nbsp;
<b class="nc">&nbsp;       Window.get().getMoveLog().removeMove(lastMove);</b>
<b class="nc">&nbsp;       Window.get().getTakenPiecesPanel().redo(Window.get().getMoveLog());</b>
<b class="nc">&nbsp;       Window.get().getBoardPanel().drawBoard(this.virtualBoard);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Questa classe rappresenta la scacchiera &quot;fisica&quot; che viene disegnata nella GUI
&nbsp;     */
&nbsp;    private class BoardPanel extends JPanel {
&nbsp;        private final List&lt;Tile&gt; boardTiles;
&nbsp;
<b class="nc">&nbsp;        public BoardPanel() {</b>
<b class="nc">&nbsp;            super(new GridLayout(8, 8));</b>
<b class="nc">&nbsp;            this.boardTiles = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            for(int i = 0; i &lt; 64; i++) {</b>
<b class="nc">&nbsp;                final Tile tile = new Tile(this, i);</b>
<b class="nc">&nbsp;                this.boardTiles.add(tile);</b>
<b class="nc">&nbsp;                this.add(tile);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            this.setPreferredSize(Constants.BOARD_DIMENSION);</b>
<b class="nc">&nbsp;            this.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));</b>
<b class="nc">&nbsp;            this.setBackground(Constants.BOARD_PANEL_BACKGROUND);</b>
<b class="nc">&nbsp;            this.validate();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo serve a ri-disegnare la scacchiera quando viene spostata una pedina o inizia il gioco
&nbsp;         * @param board scacchiera &quot;virtuale di riferimento&quot;
&nbsp;         */
&nbsp;        public void drawBoard(final VirtualBoard board) {
<b class="nc">&nbsp;            this.removeAll();</b>
&nbsp;
<b class="nc">&nbsp;            for (final Tile boardTile : boardDirection.traverse(boardTiles)) {</b>
<b class="nc">&nbsp;                boardTile.drawTile(board);</b>
<b class="nc">&nbsp;                add(boardTile);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            validate();</b>
<b class="nc">&nbsp;            repaint();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Questa classe serve a rappresentare la singola cella della scacchiera &quot;fisica&quot;
&nbsp;     */
&nbsp;    private class Tile extends JPanel {
&nbsp;        private final int tileId;
&nbsp;
<b class="nc">&nbsp;        private Color lightTileColor = Color.decode(&quot;#FFFACD&quot;);</b>
<b class="nc">&nbsp;        private Color darkTileColor = Color.decode(&quot;#593E1A&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Questo costruttore oltre a occuparsi di disegnare e impostare gli attributi, gestisce anche il click e lo spostamento
&nbsp;         * @param boardPanel scacchiera &quot;fisica&quot; di riferimento
&nbsp;         * @param tileId numero della cella. Da 0 a 63
&nbsp;         */
<b class="nc">&nbsp;        public Tile(final BoardPanel boardPanel, final int tileId) {</b>
<b class="nc">&nbsp;            super(new GridBagLayout());</b>
<b class="nc">&nbsp;            this.tileId = tileId;</b>
<b class="nc">&nbsp;            this.setPreferredSize(Constants.TILE_DIMENSION);</b>
<b class="nc">&nbsp;            this.setTileColor();</b>
<b class="nc">&nbsp;            this.setPieceIcon(virtualBoard);</b>
<b class="nc">&nbsp;            this.highlightTileBorder(virtualBoard);</b>
<b class="nc">&nbsp;            this.highlightUsable(virtualBoard);</b>
<b class="nc">&nbsp;            this.addMouseListener(new MouseListener() {</b>
&nbsp;                @Override
&nbsp;                public void mouseClicked(MouseEvent e) {
&nbsp;                    // Se il gioco è finito blocca le mosse
<b class="nc">&nbsp;                    if(VirtualBoardUtils.isEndGame(Window.get().getVirtualBoard()))</b>
&nbsp;                        return;
&nbsp;
<b class="nc">&nbsp;                    if(isRightMouseButton(e)) {</b>
<b class="nc">&nbsp;                        sourceTile = null;</b>
<b class="nc">&nbsp;                        humanMovedPiece = null;</b>
<b class="nc">&nbsp;                    } else if(isLeftMouseButton(e)) {</b>
&nbsp;                        // Se l&#39;attributo della pedina selezionata è vuoto, imposta una nuova pedina
&nbsp;                        // Altrimenti esegui il movimento della pedina
<b class="nc">&nbsp;                        if(sourceTile == null) {</b>
<b class="nc">&nbsp;                            sourceTile = virtualBoard.getPiece(tileId);</b>
<b class="nc">&nbsp;                            humanMovedPiece = sourceTile;</b>
&nbsp;
<b class="nc">&nbsp;                            if(humanMovedPiece == null)</b>
<b class="nc">&nbsp;                                sourceTile = null;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            final Move move = MoveFactory.createMove(virtualBoard, sourceTile.getPiecePosition(), tileId);</b>
<b class="nc">&nbsp;                            final MoveTransition transition = virtualBoard.getCurrentPlayer().doMove(move);</b>
&nbsp;
<b class="nc">&nbsp;                            if (transition.moveStatus().isDone()) {</b>
<b class="nc">&nbsp;                                virtualBoard = transition.toBoard();</b>
<b class="nc">&nbsp;                                moveLog.addMove(move);</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            sourceTile = null;</b>
<b class="nc">&nbsp;                            humanMovedPiece = null;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    invokeLater(() -&gt; {</b>
<b class="nc">&nbsp;                        takenPiecesPanel.redo(moveLog);</b>
<b class="nc">&nbsp;                        Window.get().moveMadeUpdate(PlayerType.HUMAN);</b>
<b class="nc">&nbsp;                        boardPanel.drawBoard(virtualBoard);</b>
&nbsp;                    });
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void mousePressed(MouseEvent e) {
&nbsp;
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void mouseReleased(MouseEvent e) {
&nbsp;
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void mouseEntered(MouseEvent e) {
&nbsp;
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void mouseExited(MouseEvent e) {
&nbsp;
<b class="nc">&nbsp;                }</b>
&nbsp;            });
<b class="nc">&nbsp;            this.validate();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo serve per ri-disegnare la cella dopo che è stata eseguita una mossa
&nbsp;         * @param board scacchiera &quot;virtuale&quot; di riferimento
&nbsp;         */
&nbsp;        public void drawTile(final VirtualBoard board) {
<b class="nc">&nbsp;            this.setTileColor();</b>
<b class="nc">&nbsp;            this.setPieceIcon(board);</b>
<b class="nc">&nbsp;            this.highlightTileBorder(board);</b>
<b class="nc">&nbsp;            this.highlightUsable(board);</b>
<b class="nc">&nbsp;            this.validate();</b>
<b class="nc">&nbsp;            this.repaint();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo si occupa di assegnare il colore di background alla cella
&nbsp;         * L&#39;attributo FIRST_ROW contiene 8 true corrispondenti agli indici della prima riga, il resto a false.
&nbsp;         * Se il numero della cella è un modulo di 2 imposta il colore chiaro, altrimenti quello scuro.
&nbsp;         * Questo ragionamento si applica anche all&#39;elseIf che però controlla le righe pari, cosi da poter avere due tipi di righe diverse, intercalati
&nbsp;         */
&nbsp;        private void setTileColor() {
<b class="nc">&nbsp;            if (VirtualBoardUtils.INSTANCE.FIRST_ROW.get(this.tileId)      ||</b>
<b class="nc">&nbsp;                    VirtualBoardUtils.INSTANCE.THIRD_ROW.get(this.tileId)  ||</b>
<b class="nc">&nbsp;                    VirtualBoardUtils.INSTANCE.FIFTH_ROW.get(this.tileId)  ||</b>
<b class="nc">&nbsp;                    VirtualBoardUtils.INSTANCE.SEVENTH_ROW.get(this.tileId)</b>
&nbsp;            ) {
<b class="nc">&nbsp;                this.setBackground(this.tileId % 2 == 0 ? lightTileColor : darkTileColor);</b>
<b class="nc">&nbsp;            } else if(VirtualBoardUtils.INSTANCE.SECOND_ROW.get(this.tileId)   ||</b>
<b class="nc">&nbsp;                    VirtualBoardUtils.INSTANCE.FOURTH_ROW.get(this.tileId)     ||</b>
<b class="nc">&nbsp;                    VirtualBoardUtils.INSTANCE.SIXTH_ROW.get(this.tileId)      ||</b>
<b class="nc">&nbsp;                    VirtualBoardUtils.INSTANCE.EIGHTH_ROW.get(this.tileId)</b>
&nbsp;            ) {
<b class="nc">&nbsp;                this.setBackground(this.tileId % 2 != 0 ? lightTileColor : darkTileColor);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo si occupa di mostrare l&#39;immagine dell&#39;icona che corrisponde a ogni pedina posizionata
&nbsp;         * @param board scacchiera virtuale con la posizione delle pedine
&nbsp;         */
&nbsp;        private void setPieceIcon(final VirtualBoard board) {
<b class="nc">&nbsp;            this.removeAll();</b>
<b class="nc">&nbsp;            final Piece actualPiece = board.getPiece(this.tileId);</b>
&nbsp;
<b class="nc">&nbsp;            if(actualPiece != null) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    final BufferedImage image = ImageIO.read(new File(</b>
<b class="nc">&nbsp;                            Constants.RESOURCE_BASE_PATH + &quot;pieceIcon/&quot; + actualPiece.getPieceUtils().toString().charAt(0) + &quot;&quot; + actualPiece + &quot;.gif&quot;));</b>
<b class="nc">&nbsp;                    this.add(new JLabel(new ImageIcon(image)));</b>
<b class="nc">&nbsp;                } catch(final IOException e) {</b>
<b class="nc">&nbsp;                    e.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo viene utilizzato per evidenziare di blu quando una cella è selezionata.
&nbsp;         * Altrimenti i bordi sono color grigio
&nbsp;         * @param board scacchiera &quot;virtuale&quot; di riferimento
&nbsp;         */
&nbsp;        private void highlightTileBorder(final VirtualBoard board) {
<b class="nc">&nbsp;            if(sourceTile != null &amp;&amp; sourceTile.getPieceUtils() == board.getCurrentPlayer().getUtils() &amp;&amp; sourceTile.getPiecePosition() == this.tileId)</b>
<b class="nc">&nbsp;                setBorder(BorderFactory.createLineBorder(Color.cyan));</b>
&nbsp;            else
<b class="nc">&nbsp;                setBorder(BorderFactory.createLineBorder(Color.GRAY));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo si occupa di aggiungere un rettangolino verde quando a una coordinata può essere posizionata
&nbsp;         * la pedina selezionata
&nbsp;         * @param board scacchiera &quot;virtuale&quot; di riferimento
&nbsp;         */
&nbsp;        private void highlightUsable(final VirtualBoard board) {
<b class="nc">&nbsp;            if(isHighlightLegalMoves()) {</b>
<b class="nc">&nbsp;                for (final Move move : this.pieceUsableMoves(board)) {</b>
<b class="nc">&nbsp;                    if (move.getDestinationCoordinate() == this.tileId) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            this.add(new JLabel(new ImageIcon(ImageIO.read(new File(Constants.RESOURCE_BASE_PATH + &quot;game/greenIndicator.png&quot;)))));</b>
<b class="nc">&nbsp;                        } catch (final IOException e) {</b>
<b class="nc">&nbsp;                            e.printStackTrace();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo serve a ottenere le mosse possibili in questo momento per sapere quale mettere in rettangolino
&nbsp;         * @param board scacchiera &quot;virtuale&quot; di riferimento
&nbsp;         * @return una lista di mosse
&nbsp;         */
&nbsp;        private Collection&lt;Move&gt; pieceUsableMoves(final VirtualBoard board) {
<b class="nc">&nbsp;            if(sourceTile != null &amp;&amp; sourceTile.getPieceUtils() == board.getCurrentPlayer().getUtils())</b>
<b class="nc">&nbsp;                return sourceTile.calculateMoves(board);</b>
&nbsp;
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
<b class="nc">&nbsp;    private static class TableGameAIWatcher implements Observer {</b>
&nbsp;
&nbsp;        /**
&nbsp;         *
&nbsp;         * @param o     the observable object.
&nbsp;         * @param arg   an argument passed to the {@code notifyObservers}
&nbsp;         *                 method.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void update(Observable o, Object arg) {
<b class="nc">&nbsp;            if(Window.get().getVirtualBoard().getCurrentPlayer().getUtils().isBlack() &amp;&amp;</b>
<b class="nc">&nbsp;                !Window.get().getVirtualBoard().getCurrentPlayer().isInCheckMate() &amp;&amp;</b>
<b class="nc">&nbsp;                !Window.get().getVirtualBoard().getCurrentPlayer().isInStaleMate()) {</b>
<b class="nc">&nbsp;                final AIThinkThank thinkThank = new AIThinkThank();</b>
<b class="nc">&nbsp;                thinkThank.execute();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (Window.get().getVirtualBoard().getCurrentPlayer().isInCheckMate()) {</b>
<b class="nc">&nbsp;                JOptionPane.showMessageDialog(Window.get().getBoardPanel(),</b>
<b class="nc">&nbsp;                        &quot;Game Over: Giocatore &quot; + Window.get().getVirtualBoard().getCurrentPlayer() + &quot; è sotto scacco matto!&quot;, &quot;Game Over&quot;,</b>
&nbsp;                        JOptionPane.INFORMATION_MESSAGE);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (Window.get().getVirtualBoard().getCurrentPlayer().isInStaleMate()) {</b>
<b class="nc">&nbsp;                JOptionPane.showMessageDialog(Window.get().getBoardPanel(),</b>
<b class="nc">&nbsp;                        &quot;Game Over: Giocatore &quot; + Window.get().getVirtualBoard().getCurrentPlayer() + &quot; è in una situazione di blocco (stallo)!&quot;, &quot;Game Over&quot;,</b>
&nbsp;                        JOptionPane.INFORMATION_MESSAGE);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static class AIThinkThank extends SwingWorker&lt;Move, String&gt;{
&nbsp;
<b class="nc">&nbsp;        private AIThinkThank() {</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo viene chiamato dall&#39;observer dell&#39;AI e si occupa di eseguire
&nbsp;         * la logica della AI del giocatore.
&nbsp;         * Valuterà dunque tutte le mosse e sceglierà la migliore
&nbsp;         * @return
&nbsp;         */
&nbsp;        @Override
&nbsp;        protected Move doInBackground() {
<b class="nc">&nbsp;            final StockAlphaBeta strategy = new StockAlphaBeta(2);</b>
<b class="nc">&nbsp;            return strategy.execute(Window.get().getVirtualBoard());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         *
&nbsp;         */
&nbsp;        @Override
&nbsp;        protected void done() {
&nbsp;            try {
<b class="nc">&nbsp;                final Move bestMove = get();</b>
<b class="nc">&nbsp;                Window.get().updateComputerMove(bestMove);</b>
<b class="nc">&nbsp;                Window.get().updateGameBoard(Window.get().getVirtualBoard().getCurrentPlayer().doMove(bestMove).toBoard());</b>
<b class="nc">&nbsp;                Window.get().getMoveLog().addMove(bestMove);</b>
<b class="nc">&nbsp;                Window.get().getTakenPiecesPanel().redo(Window.get().getMoveLog());</b>
<b class="nc">&nbsp;                Window.get().getBoardPanel().drawBoard(Window.get().getVirtualBoard());</b>
<b class="nc">&nbsp;                Window.get().moveMadeUpdate(PlayerType.COMPUTER);</b>
<b class="nc">&nbsp;            } catch(final Exception e) {</b>
<b class="nc">&nbsp;                e.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     */
<b class="nc">&nbsp;    private enum BoardDirection {</b>
<b class="nc">&nbsp;        NORMAL {</b>
&nbsp;            @Override
&nbsp;            List&lt;Tile&gt; traverse(final List&lt;Tile&gt; boardTiles) {
<b class="nc">&nbsp;                return boardTiles;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            BoardDirection opposite() {
<b class="nc">&nbsp;                return FLIPPED;</b>
&nbsp;            }
&nbsp;        },
<b class="nc">&nbsp;        FLIPPED {</b>
&nbsp;            @Override
&nbsp;            List&lt;Tile&gt; traverse(final List&lt;Tile&gt; boardTiles) {
<b class="nc">&nbsp;                return Lists.reverse(boardTiles);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            BoardDirection opposite() {
<b class="nc">&nbsp;                return NORMAL;</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo serve a invertire la board
&nbsp;         * @param boardTiles celle della scacchiera fisica
&nbsp;         * @return lista di celle ordinate
&nbsp;         */
&nbsp;        abstract List&lt;Tile&gt; traverse(final List&lt;Tile&gt; boardTiles);
&nbsp;
&nbsp;        /**
&nbsp;         * Questo metodo serve a trovare l&#39;opposto della configurazione attuale
&nbsp;         * @return l&#39;opposto. ex: NORMAL --&gt; FLIPPED
&nbsp;         */
&nbsp;        abstract BoardDirection opposite();
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-03-19 21:16</div>
</div>
</body>
</html>
